#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <errno.h>
#include <sys/stat.h>
#include <stdlib.h>
pthread_t thread_list[100];
int thread_list_id[100];
int num_thread=0;
char buffer[256];
void *thread_function(void *arg);
void send_file(int sock,char* fn);
int main(int argc, char **argv)
{
		int sockfd,newsockfd,portno,clilen,n;
		struct sockaddr_in serv_addr,cli_addr;
		int rc;
		
		if (argc < 2){
				fprintf(stderr,"ERROR, no port provided");
				exit(1);
		}
		
		sockfd = socket(AF_INET,SOCK_STREAM,0);
		if (sockfd < 0)
			error("ERROR opening socket");
		bzero((char *)&serv_addr,sizeof(serv_addr));
		
		portno = atoi(argv[1]);
		
		serv_addr.sin_family = AF_INET;
		serv_addr.sin_port = htons(portno);
		
		rc =  bind(sockfd, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
		if (rc == -1) {
			fprintf(stderr, "unable to bind to socket\n");
			exit(1);
		}
		
		listen(sockfd,5);
		while (1){
			clilen = sizeof(cli_addr);
			newsockfd = accept(sockfd, (struct sockaddr *) &cli_addr, &clilen);
			if (newsockfd < 0){
				error("ERROR on accept");
			}
			thread_list_id[num_thread] = pthread_create( &(thread_list[num_thread]), NULL, thread_function, (void *)newsockfd  );
			if (thread_list_id[num_thread] != 0){
				perror("Thread create failed!\n");
				exit(1);
			}
			num_thread ++;
		}
		return 0;			
}
void *thread_function(void *arg){
	int numbytes=0, th_num=0, *p_th_num;
	char filename[100];
	int rc;
	int sockid;
	sockid = (int *)arg;
	
	//Reading command
	while (1){
		bzero(buffer,255);
		#ifdef DEBUG
			printf("from sockid %d \n",sockid);
		#endif
		rc = read(sockid,buffer,255);
		if (rc < 0){
			printf("error");
		}
		printf("command: %s \n",buffer);
		if (!strcmp(buffer,"quit")){
				
		}else
		if (!strcmp(buffer,"ls")){
			//n = write(sockid,"I got your message",18);
			#ifdef DEBUG
				printf("command ls\n");
			#endif
		}
		else
		if (!strcmp(buffer,"cat")){
				
		}else
		if (!strcmp(buffer,"download")){
				//read file name
				#ifdef DEBUG
					printf("waiting for filename from socketid %d \n",sockid);
				#endif
				rc = read(sockid,buffer,255);
				if (rc < 0){
						printf("ERROR reading filename\n");
						exit(1);
				}
				send_file(sockid,buffer);
		}
		
	}
	printf("\nquite\n");
	//streaming
	close(sockid);
	return NULL;
}
void send_file_info(int sockid,char *command){
	int rc;
	printf("filesize %s\n",command);
	rc = write(sockid,command,strlen(command));
	if (rc == -1){
		printf("error");
	}
}
void send_file(int sock,char* fn) 
{ 
    char buf[1025]; 
    const char* filename = fn; 
    struct stat st;
    int size;
    char size_file[20];
    int total = 0;
    FILE *file = fopen(filename, "rb"); 
	
	stat(filename, &st);
	size = st.st_size;
	sprintf(size_file, "%d", size);
	send_file_info(sock,size_file);
    if (!file)
    {
        printf("Can't open file for reading"); 
        return;
    }
    while (!feof(file)) 
    { 
        int rval = fread(buf, 1, sizeof(buf), file); 
        if (rval < 1)
        {
            printf("Can't read from file");
            fclose(file);
            return;
        }

        int off = 0;
        do
        {
            int sent = send(sock, &buf[off], rval - off, 0);
            if (sent < 1)
            {
                // if the socket is non-blocking, then check
                // the socket error for WSAEWOULDBLOCK/EAGAIN
                // (depending on platform) and if true then
                // use select() to wait for a small period of
                // time to see if the socket becomes writable
                // again before failing the transfer...

                printf("Can't write to socket");
                fclose(file);
                return;
            }

            off += sent;
        }
        while (off < rval);
        
    } 
    
    printf("done\n");
    fclose(file);
} 
